<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.7.1"><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="Let’s implement a language - Part 3 - The Parser" /><meta name="author" content="Félix-Antoine Ouellet" /><meta property="og:locale" content="en_US" /><meta name="description" content="In our biggest installment yet, we finally build the AST that was promised." /><meta property="og:description" content="In our biggest installment yet, we finally build the AST that was promised." /><link rel="canonical" href="https://faouellet.github.io//toslang-parser/" /><meta property="og:url" content="https://faouellet.github.io//toslang-parser/" /><meta property="og:site_name" content="/* Insert Code Here */" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2016-07-01T00:00:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Let’s implement a language - Part 3 - The Parser" /> <script type="application/ld+json"> {"description":"In our biggest installment yet, we finally build the AST that was promised.","url":"https://faouellet.github.io//toslang-parser/","headline":"Let’s implement a language - Part 3 - The Parser","dateModified":"2016-07-01T00:00:00-04:00","@type":"BlogPosting","datePublished":"2016-07-01T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://faouellet.github.io//toslang-parser/"},"author":{"@type":"Person","name":"Félix-Antoine Ouellet"},"@context":"https://schema.org"}</script><title>Let's implement a language - Part 3 - The Parser | /* Insert Code Here */</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" href="/assets/css/post.css" as="style"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-71911238-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-71911238-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">/* Insert Code Here */</a></div><div class="site-subtitle font-italic"></div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/faouellet" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/felixantoineouellet/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['faouellet','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Let's implement a language - Part 3 - The Parser</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Let's implement a language - Part 3 - The Parser</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Jul 1, 2016, 12:00 AM -0400" > Jul 1, 2016 <i class="unloaded">2016-07-01T00:00:00-04:00</i> </span> by <span class="author"> Félix-Antoine Ouellet </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2734 words">15 min</span></div></div><div class="post-content"><p>Hey everyone!</p><p>Continuing our journey toward a fully working compiler, we will now build the parser that will allow us to produce an AST out of program we received as input.</p><figure><p style="text-align:center;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/Frontend3.png" alt="Image: Ever closer to being done with the frontend" /></p><figcaption><span><center><i>Ever closer to being done with the frontend</i></center></span></figcaption></figure><p>However, before diving into the parser, some things must be taken care of.</p><h2 id="refactoring-the-lexer">Refactoring the lexer</h2><p>The lexer that we previously built is fine as a first draft that (mostly) follows common (and old!) language building design. However, such a design might not scale well when working with sizeable programs from (verbose) programming languages.</p><figure><p style="text-align:center;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/verbose.jpg" alt="Image: Definitely not thinking about a language in particular" /></p><figcaption><span><center><i>Definitely not thinking about a language in particular</i></center></span></figcaption></figure><p>The thing is that lexing such programs all at once will rapidly consume way too much memory. And this is only for producing tokens. Just imagine if we want to also want to produce informations about the source location of a token or the identifier associated with a token. All of this adds up to a hefty price in memory consumption.</p><p>The thing to realize about the lexer and the parser is that they’re not two out-of-touch entities that only communicate when the lexer hands off a token sequence to the parser. In reality, they’re two cooperating entities that work together to produce an AST out of the text of a program. This is why they’re so often used as <a href="https://www.youtube.com/watch?v=_fu0gx-xseY">a motivating example for what coroutines might be useful for</a>.</p><p>Thus, in the real world, lexers more often than not offers services to fetch tokens from a program one at a time and not to get them all at the same time. For those of you that know a bit about Flex and Bison, this should feel pretty familiar since this is how the lexers and parsers they generate operate.</p><p>With all that said, let’s modernize our lexer. First, let’s go over the <code class="language-plaintext highlighter-rouge">Lexer</code> class definition.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Lexer</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Lexer</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">programStr</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">mProgram</span><span class="p">{</span> <span class="n">programStr</span> <span class="p">},</span>
      <span class="n">mProgramIt</span><span class="p">{</span> <span class="n">mProgram</span><span class="p">.</span><span class="n">cbegin</span><span class="p">()</span> <span class="p">}.</span>
      <span class="n">mProgramEnd</span><span class="p">{</span> <span class="n">mProgram</span><span class="p">.</span><span class="n">cend</span><span class="p">()</span> <span class="p">},</span>
      <span class="n">mLoc</span><span class="p">{</span> <span class="s">""</span> <span class="p">}</span> <span class="p">{};</span>

  <span class="c1">// Advances the lexer to the next token and returns it</span>
  <span class="n">Token</span> <span class="n">GetNextToken</span><span class="p">();</span>

  <span class="c1">// Some accessors</span>
  <span class="kt">int</span> <span class="n">GetCurrentNumber</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mCurrentNumber</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">GetCurrentIdentifier</span><span class="p">()</span> <span class="k">const</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">mCurrentIdentifier</span><span class="p">;</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">mProgram</span><span class="p">;</span>           <span class="cm">/*!&lt; Program text */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">mProgramIt</span><span class="p">;</span>  <span class="cm">/*!&lt; Program iterator */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">mProgramEnd</span><span class="p">;</span> <span class="cm">/*!&lt; Program end */</span>

  <span class="kt">int</span> <span class="n">mCurrentNumber</span><span class="p">;</span>             <span class="cm">/*!&lt; Current number */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">mCurrentIdentifier</span><span class="p">;</span> <span class="cm">/*!&lt; Current var/func identifier */</span>

  <span class="n">std</span><span class="o">::</span><span class="n">locale</span> <span class="n">mLoc</span><span class="p">;</span>               <span class="cm">/*!&lt; The source locale */</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Compared to the previous version of the <code class="language-plaintext highlighter-rouge">Lexer</code> class definition, this one contains way more data members. The first three ones are there to enable the <code class="language-plaintext highlighter-rouge">Lexer</code> to go over a program’s text. The next two (<code class="language-plaintext highlighter-rouge">mCurrentNumber</code> and <code class="language-plaintext highlighter-rouge">mCurrentIdentifier</code>) will allow us to transmit some informations that the parser might require. For example, what is the name of the function in a call expression or what is the value of a number literal. This all ties into the fact that in the <code class="language-plaintext highlighter-rouge">Lexer</code>-<code class="language-plaintext highlighter-rouge">Parser</code> relationship, the <code class="language-plaintext highlighter-rouge">Lexer</code> is the one that has to deal directly with the program’s textual representation while the <code class="language-plaintext highlighter-rouge">Parser</code> toils away building the AST. Finally, the last one (<code class="language-plaintext highlighter-rouge">mLoc</code>) is there because we need to take into account the program’s locale when lexing it.</p><p>The other major difference from the previous definition, is the function for getting tokens out of a program. As you can see from the function signature, we ditched the token stream approach and now the function will only give out one token at a time. Its implementation stays mostly the same, only now we don’t loop over all the program’s text ine one go.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
</pre><td class="rouge-code"><pre><span class="n">Token</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">GetNextToken</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Skip over whitespaces</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">mProgramIt</span> <span class="o">!=</span> <span class="n">mProgramEnd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">mPogramIt</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="o">++</span><span class="n">programIt</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// End of file, we're done</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mProgramIt</span> <span class="o">==</span> <span class="n">mProgramEnd</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">Token</span><span class="o">::</span><span class="n">TOK_EOF</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Caching the current char because we will use it A LOT</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="n">currentChar</span> <span class="o">=</span> <span class="o">*</span><span class="n">programIt</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">currentChar</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="sc">','</span><span class="p">:</span>
    <span class="o">++</span><span class="n">mProgramIt</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Token</span><span class="o">::</span><span class="n">COMMA</span><span class="p">;</span>

  <span class="c1">// Lots of similar cases for simple one character tokens</span>

  <span class="nl">default:</span>  
    <span class="c1">// We have a token coming from a more complex pattern,</span>
    <span class="c1">// let's find out what</span>

    <span class="c1">// If this starts with a letter,</span>
    <span class="c1">// it is either a keyword or an identifier</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">currentChar</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="c1">// Let's greedily build a string with the pattern</span>
      <span class="n">mCurrentIdentifier</span> <span class="o">=</span> <span class="n">currentChar</span><span class="p">;</span>
      <span class="c1">// We accept alphanumeric characters because it is legal for a</span>
      <span class="c1">// function or variable identifier to contains number</span>
      <span class="k">while</span> <span class="p">((</span><span class="o">++</span><span class="n">mProgramIt</span> <span class="o">!=</span> <span class="n">mProgramEnd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isalnum</span><span class="p">(</span><span class="o">*</span><span class="n">mProgramIt</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>
      <span class="p">{</span>
        <span class="n">mCurrentIdentifier</span> <span class="o">+=</span> <span class="o">*</span><span class="n">mProgramIt</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">mCurrentIdentifier</span> <span class="o">==</span> <span class="s">"fn"</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="n">Token</span><span class="o">::</span><span class="n">FUNCTION</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// Other cases where the pattern directly match</span>
      <span class="c1">// a keyword token...</span>
      <span class="k">else</span>
      <span class="p">{</span>
        <span class="c1">// If this doesn't match a keyword,</span>
        <span class="c1">// then it is a simple identifier.</span>
        <span class="c1">// We'll be able to ask for it throught GetCurrentIdentifier</span>
        <span class="k">return</span> <span class="n">Token</span><span class="o">::</span><span class="n">IDENTIFIER</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// It starts with a digit, then it can only be a number</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">currentChar</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">numberStr</span><span class="p">;</span>

      <span class="c1">// Eat up all the digits making up the number</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">++</span><span class="n">mProgramIt</span><span class="p">,</span> <span class="n">loc</span><span class="p">)))</span>
      <span class="p">{</span>
        <span class="n">numberStr</span> <span class="o">+=</span> <span class="o">*</span><span class="n">mProgramIt</span>
      <span class="p">}</span>

      <span class="c1">// We'll be able to ask for it throught GetCurrentNumber</span>
      <span class="n">mCurrentNumber</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">numberStr</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Token</span><span class="o">::</span><span class="n">NUMBER</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="c1">// The hell is that?</span>
      <span class="k">return</span> <span class="n">Token</span><span class="o">::</span><span class="n">UNKNOWN</span><span class="p">;</span>  
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>With these few changes, we should be able to scale a bit better now. Also, this new version of the <code class="language-plaintext highlighter-rouge">Lexer</code> could easily accomodate a lookahead feature if TosLang’s grammar ever evolves in such a way that it might need it to disambiguate some of its rules.</p><h2 id="the-parser">The parser</h2><p>For a post about the parser there sure is a lack of it so far! Let’s fix this. As the interface to our <code class="language-plaintext highlighter-rouge">Parser</code>, I suggest the following:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="n">ExprPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Parser</span>
<span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">Parser</span><span class="p">()</span> <span class="o">:</span> <span class="n">mLexer</span><span class="p">{</span> <span class="p">},</span> <span class="n">mCurrentToken</span><span class="p">{</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">UNKNOWN</span> <span class="p">}</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ASTNode</span><span class="o">&gt;</span> <span class="n">ParseProgram</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>

  <span class="nl">private:</span>  <span class="c1">// Declarations</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ASTNode</span><span class="o">&gt;</span>      <span class="n">ParseProgramDecl</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">FunctionDecl</span><span class="o">&gt;</span> <span class="n">ParseFunctionDecl</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">VarDecl</span><span class="o">&gt;</span>      <span class="n">ParseVarDecl</span><span class="p">();</span>

  <span class="nl">private:</span>  <span class="c1">// Expressions</span>
    <span class="n">ExprPtr</span> <span class="n">ParseExpr</span><span class="p">();</span>
    <span class="n">ExprPtr</span> <span class="n">ParseArrayExpr</span><span class="p">();</span>
    <span class="n">ExprPtr</span> <span class="n">ParseBinaryOpExpr</span><span class="p">(</span><span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span> <span class="n">operationToken</span><span class="p">,</span>
                              <span class="n">ExprPtr</span><span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">);</span>
    <span class="n">ExprPtr</span> <span class="n">ParseCallExpr</span><span class="p">(</span><span class="n">ExprPtr</span><span class="o">&amp;&amp;</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isSpawnedExpr</span><span class="p">);</span>

  <span class="nl">private:</span>    <span class="c1">// Statements</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CompoundStmt</span><span class="o">&gt;</span> <span class="n">ParseCompoundStmt</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IfStmt</span><span class="o">&gt;</span>       <span class="n">ParseIfStmt</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PrintStmt</span><span class="o">&gt;</span>    <span class="n">ParsePrintStmt</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ReturnStmt</span><span class="o">&gt;</span>   <span class="n">ParseReturnStmt</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ScanStmt</span><span class="o">&gt;</span>     <span class="n">ParseScanStmt</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">WhileStmt</span><span class="o">&gt;</span>    <span class="n">ParseWhileStmt</span><span class="p">();</span>

  <span class="nl">private:</span>
    <span class="n">Lexer</span> <span class="n">mLexer</span><span class="p">;</span>               <span class="cm">/*!&lt; Lexer used by the parser
                                     to acquire tokens */</span>
    <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span> <span class="n">mCurrentToken</span><span class="p">;</span> <span class="cm">/*!&lt; Current token being treated
                                     by the parser */</span>
<span class="p">};</span>
</pre></table></code></div></div><p>This implementation ties into what I previously wrote about the roles in the <code class="language-plaintext highlighter-rouge">Lexer</code>-<code class="language-plaintext highlighter-rouge">Parser</code> relationship. To wit, the <code class="language-plaintext highlighter-rouge">mLexer</code> member variable will be there to analyze the program’s text and lazily supply the <code class="language-plaintext highlighter-rouge">Parser</code> with tokens. The <code class="language-plaintext highlighter-rouge">mCurrentToken</code> is there as a caching mechanism because the <code class="language-plaintext highlighter-rouge">Parser</code> will put it through quite the grinder when trying to match <a href="https://github.com/faouellet/Tostitos/blob/master/docs/TosLangGrammar.txt">TosLang’s grammar rules</a>.</p><p>The proposed interface also make echo to <a href="https://faouellet.github.io/toslang-ast/">what I wrote last month</a> about the relations between nodes in the AST. For those of you that don’t remember, the AST that we’re about to build uses <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> to both ease memory management and make clear the intent that a parent node is the unique owner of its child nodes. Consequently, it’s only natural that the <code class="language-plaintext highlighter-rouge">Parser</code> that is going to create this AST be made of functions producing <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> of nodes that can then be moved into a parent node.</p><p>The last thing to mention about this interface is that the only service this class will offer to its clients is to produce an AST from a file. This is merely for educational purposes, I just want the <code class="language-plaintext highlighter-rouge">Parser</code> to be standalone for the moment. Now then, let’s have a look at the implementation.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ASTNode</span><span class="o">&gt;</span>
    <span class="n">Parser</span><span class="o">::</span><span class="n">ParseProgram</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// We're only dealing with TosLang file</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="p">(</span><span class="n">filename</span><span class="p">).</span><span class="n">extension</span><span class="p">()</span> <span class="o">!=</span> <span class="s">".tos"</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Can't go ahead with the parsing if the lexer isn't ready</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mLexer</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Let's get it on!</span>
  <span class="k">return</span> <span class="n">ParseProgramDecl</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Basically, this method just make sure that everything is set up for the parsing and then jumps into <code class="language-plaintext highlighter-rouge">ParseProgramDecl</code> to start the actual parsing. Remember that following the TosLang’s grammar, the root of any program is a node of the <code class="language-plaintext highlighter-rouge">ProgramDecl</code> type.</p><p>Before continuing, however, I realize some may be stuck on the line where is invoke a standard function to ask about a file extension. No, you’re not dreaming. This is <a href="http://en.cppreference.com/w/cpp/filesystem">a C++17 feature</a> that’s coming to a standard library near you (if your preferred standard library implementation doesn’t already offers it).</p><p>Now let’s see how we parse a <code class="language-plaintext highlighter-rouge">ProgramDecl</code>:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ASTNode</span><span class="o">&gt;</span> <span class="n">Parser</span><span class="o">::</span><span class="n">ParseProgramDecl</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// ProgramDecl ::= Decls</span>
  <span class="k">auto</span> <span class="n">programNode</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ProgramDecl</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">mCurrentToken</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetNextToken</span><span class="p">();</span>
  
  <span class="c1">// Decls ::= Decl Decls</span>
  <span class="c1">//       ::= Decl</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Decl</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Decl</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">TOK_EOF</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Decl ::= FnDecl</span>
    <span class="c1">//      ::= VarDecl</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">mCurrentToken</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">case</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">FUNCTION</span><span class="p">:</span>
        <span class="n">node</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">ParseFunctionDecl</span><span class="p">().</span><span class="n">release</span><span class="p">());</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">VAR</span><span class="p">:</span>
        <span class="n">node</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">ParseVarDecl</span><span class="p">().</span><span class="n">release</span><span class="p">());</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">programNode</span><span class="o">-&gt;</span><span class="n">AddProgramDecl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>

    <span class="c1">// Go to next declaration.</span>
    <span class="c1">// In case an error happens, this will skip straight</span>
    <span class="c1">// to the next declaration</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">mCurrentToken</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">VAR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
           <span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">FUNCTION</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
           <span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">TOK_EOF</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">mCurrentToken</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetNextToken</span><span class="p">();</span>  
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">programNode</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Here, in lieu of comments I chose to describe part of the function with grammar production rules. This was done to make clear that implementing a parser, in its most basic form, is just a translation from these rules to code. More often than not, a language’s grammar rules can be divided into three categories for parsing. Let’s examine them with examples from TosLang.</p><h2 id="1-rules-producing-a-terminal-node">1. Rules producing a terminal node</h2><p>These rules produce a terminal node like a number or a string literal. In that case, we can just parse them and produce the corresponding node without much hassle. As an example, here’s how to parse a string literal of TosLang.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// StringExpr = '"' identifier '"'</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">StringExpr</span><span class="o">&gt;</span> <span class="n">Parser</span><span class="o">::</span><span class="n">ParseStringExpr</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">==</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">STRING_LITERAL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">StringExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mLexer</span><span class="p">.</span><span class="n">GetCurrentIdentifier</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It’s so simple, the lexer took care of everything!</p><h2 id="2-rules-producing-an-intermediate-node">2. Rules producing an intermediate node</h2><p>These rules concern elements of the language such as declarations (either of functions or variables) or non-terminal expressions like arithmetic expressions. These will require that we dig down into each element that make up the intermediate node to parse them before dealing with the intermediate node. This digging may further continue if one or more elements of the intermediate node are also intermediate nodes themselves. An example of such a rule in TosLang is the rule concerning variable declarations.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre><td class="rouge-code"><pre><span class="c1">// VarDecl ::= 'var' IdentifierExpr ':' TypeExpr ( '=' Expr )? ';'</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">VarDecl</span><span class="o">&gt;</span> <span class="n">Parser</span><span class="o">::</span><span class="n">ParseVarDecl</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">VarDecl</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">VarDecl</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="c1">// Get the variable name</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">mCurrentToken</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetNextToken</span><span class="p">())</span>
        <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">IDENTIFIER</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">varName</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetCurrentStr</span><span class="p">();</span>

  <span class="c1">// Make sure the variable name is followed by a colon</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">mCurrentToken</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetNextToken</span><span class="p">())</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">COLON</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Check that a type token is following the colon</span>
  <span class="c1">// in the variable declaration</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">mCurrentToken</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetNextToken</span><span class="p">())</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">TYPE</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Get the type of the variable</span>
  <span class="n">Common</span><span class="o">::</span><span class="n">Type</span> <span class="n">vType</span> <span class="o">=</span> <span class="n">GetTypeFromIdentifier</span><span class="p">(</span><span class="n">mCurrentToken</span><span class="p">);</span>
  
  <span class="c1">// Is the variable a scalar or an array?</span>
  <span class="n">mCurrentToken</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetNextToken</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">varSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// We define a scalar as having a size of zero.</span>
                      <span class="c1">// A zero-length array is thus illegal.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">==</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">LEFT_BRACKET</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ParseArrayType</span><span class="p">(</span><span class="n">varSize</span><span class="p">,</span> <span class="n">vType</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">VarDecl</span><span class="o">*</span> <span class="n">vDecl</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VarDecl</span><span class="p">(</span><span class="n">varName</span><span class="p">,</span> <span class="n">vType</span><span class="p">,</span> <span class="cm">/*isFunctionParam=*/</span><span class="nb">false</span><span class="p">,</span> <span class="n">varSize</span><span class="p">);</span>

  <span class="c1">// The variable may be initialized when it is declared</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">==</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">ASSIGN</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">mCurrentToken</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetNextToken</span><span class="p">();</span>
    <span class="c1">// Adding initialization expression if possible</span>
    <span class="c1">// If it's not, then we're in an error state we need to get out of</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vDecl</span><span class="o">-&gt;</span><span class="n">AddInitialization</span><span class="p">(</span><span class="n">ParseExpr</span><span class="p">()))</span>
    <span class="p">{</span>
      <span class="k">delete</span> <span class="n">vDecl</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// We can only produce the VarDecl node</span>
  <span class="c1">// if the statement is properly terminated</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">==</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">SEMI_COLON</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">node</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">vDecl</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="3-rules-with-recursion">3. Rules with recursion</h2><p>There exists rules within a grammar to specify that a sequence of node of the same type will be produced. These will take the form of recursive rules such as the one in <code class="language-plaintext highlighter-rouge">ParseProgramDecl</code> that specify that a <code class="language-plaintext highlighter-rouge">ProgramDecl</code> is made of several <code class="language-plaintext highlighter-rouge">Decls</code>. Such rules can be translated into code by turning them into <code class="language-plaintext highlighter-rouge">while</code> loops. As an example, let’s look at what happens when parsing the parameters of a function declaration</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
</pre><td class="rouge-code"><pre><span class="c1">// ParamDecl     ::= '(' ParamVarDecls ')'</span>
<span class="c1">// ParamVarDecls ::= ParamVarDecl ',' ParamVarDecls</span>
<span class="c1">// ParamVarDecl  ::= IdentifierExpr ':' Type</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ParamVarDecl</span><span class="o">&gt;</span> <span class="n">ParseParamVarDecl</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// We must start at a left parenthesis</span>
  <span class="k">if</span><span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">LEFT_PAREN</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">params</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ParamVarDecl</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">VarDecl</span><span class="o">&gt;</span> <span class="n">param</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">varName</span><span class="p">;</span>

  <span class="n">mCurrentToken</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetNextToken</span><span class="p">();</span>
  <span class="c1">// We'll parse each parameter one at a time through this loop</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">mCurrentToken</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">RIGHT_PAREN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">TOK_EOF</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="c1">// The parameter must have an identifier</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">IDENTIFIER</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">varName</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetCurrentStr</span><span class="p">();</span>

    <span class="c1">// The identifier must be followed by a colon</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">mCurrentToken</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetNextToken</span><span class="p">())</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">COLON</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// After the colon there must be a type specification</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">mCurrentToken</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetNextToken</span><span class="p">())</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">TYPE</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Common</span><span class="o">::</span><span class="n">Type</span> <span class="n">vType</span> <span class="o">=</span> <span class="n">GetTypeFromIdentifier</span><span class="p">(</span><span class="n">mCurrentToken</span><span class="p">);</span>

    <span class="c1">// Is the variable a scalar or an array?</span>
    <span class="n">mCurrentToken</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetNextToken</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">varSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// We define a scalar as having a size of zero.</span>
                        <span class="c1">// A zero-length array is thus illegal.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">==</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">LEFT_BRACKET</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ParseArrayType</span><span class="p">(</span><span class="n">varSize</span><span class="p">,</span> <span class="n">vType</span><span class="p">))</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="n">fnNode</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// We successfully parse a parameter</span>
    <span class="n">param</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">VarDecl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">varName</span><span class="p">,</span> <span class="n">vType</span><span class="p">,</span>
                                          <span class="cm">/*isFunctionParam=*/</span><span class="nb">true</span><span class="p">,</span>
                                          <span class="n">varSize</span><span class="p">).</span><span class="n">release</span><span class="p">());</span>

    <span class="c1">// Bailing out of the function if we're not at the end of the</span>
    <span class="c1">// parameters declaration or in-between two parameter declarations.</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">mCurrentToken</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">RIGHT_PAREN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">COMMA</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Everything's good, let's add another parameter</span>
    <span class="n">params</span><span class="o">-&gt;</span><span class="n">AddParameter</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>

    <span class="c1">// We may be done here. If that's the case, get out of the loop</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">==</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">RIGHT_PAREN</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Let's go for another one</span>
    <span class="n">mCurrentToken</span> <span class="o">=</span> <span class="n">mLexer</span><span class="p">.</span><span class="n">GetNextToken</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// We'll only return the parameters declaration if</span>
  <span class="c1">// we're at the expected end of the statement</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mCurrentToken</span> <span class="o">!=</span> <span class="n">Lexer</span><span class="o">::</span><span class="n">Token</span><span class="o">::</span><span class="n">RIGHT_PAREN</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>  

  <span class="k">return</span> <span class="n">params</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Following these guidelines, one is able to implement what is commonly referred to in formal parlance as a recursive descent parser. In other words, what we described is a parser that will start by generating terminal nodes to then assemble them together to produce the AST.</p><p>Finally, take note that the implementation presented doesn’t handle errors in any way. This is a topic for another post.</p><p>For more details on the implementation of TosLang’s <code class="language-plaintext highlighter-rouge">Parser</code>, you can go check the full source code <a href="https://github.com/faouellet/Tostitos/tree/master/TosLang/Parse">here</a>.</p><p><strong>Coming up next month</strong>: Starting semantic analysis with something quite curious…</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/toslang/'>TosLang</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/compiler-development/" class="post-tag no-text-decoration" >Compiler Development</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Let's implement a language - Part 3 - The Parser - /* Insert Code Here */&url=https://faouellet.github.io//toslang-parser/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Let's implement a language - Part 3 - The Parser - /* Insert Code Here */&u=https://faouellet.github.io//toslang-parser/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Let's implement a language - Part 3 - The Parser - /* Insert Code Here */&url=https://faouellet.github.io//toslang-parser/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/database/">Database</a> <a class="post-tag" href="/tags/source-control/">Source Control</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/build-system/">Build System</a> <a class="post-tag" href="/tags/parallelism/">Parallelism</a> <a class="post-tag" href="/tags/compiler-development/">Compiler Development</a> <a class="post-tag" href="/tags/software-development/">Software Development</a> <a class="post-tag" href="/tags/c-amp/">C++AMP</a> <a class="post-tag" href="/tags/concurrency/">Concurrency</a> <a class="post-tag" href="/tags/gpgpu/">GPGPU</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/toslang-lexer/"><div class="card-body"> <span class="timeago small" > May 6, 2016 <i class="unloaded">2016-05-06T00:00:00-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Let's implement a language - Part 1 - The Lexer</h3><div class="text-muted small"><p> Hey everyone! This month marks the beginning of our journey into compiler development territory. For our first steps, we’ll start with an overview of modern compiler architecture and the developme...</p></div></div></a></div><div class="card"> <a href="/toslang-ast/"><div class="card-body"> <span class="timeago small" > Jun 3, 2016 <i class="unloaded">2016-06-03T00:00:00-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Let's implement a language - Part 2 - The AST</h3><div class="text-muted small"><p> Hey everyone! Last time, we opened up the black box that is a modern compiler to see that it what is fact three black boxes linked together. Those three again We then delved...</p></div></div></a></div><div class="card"> <a href="/toslang-intro/"><div class="card-body"> <span class="timeago small" > Apr 1, 2016 <i class="unloaded">2016-04-01T00:00:00-04:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Let's implement a language - Part 0 - Intro</h3><div class="text-muted small"><p> Hey everyone! Starting this month, I’ll take you through my personal journey to develop a compiler for a language of my own design. While the next posts in this series will be quite technical, I’d...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/toslang-ast/" class="btn btn-outline-primary"><p>Let's implement a language - Part 2 - The AST</p></a> <a href="/toslang-hiatus/" class="btn btn-outline-primary"><p>Let's implement a language - Hiatus</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="font-italic text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> var options = { scriptUrl: '//insertcodehere.disqus.com/embed.js', disqusConfig: function() { this.page.url = 'https://faouellet.github.io//toslang-parser/'; this.page.identifier = '/toslang-parser/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/faouellet">Félix-Antoine Ouellet</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/database/">Database</a> <a class="post-tag" href="/tags/source-control/">Source Control</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/build-system/">Build System</a> <a class="post-tag" href="/tags/parallelism/">Parallelism</a> <a class="post-tag" href="/tags/compiler-development/">Compiler Development</a> <a class="post-tag" href="/tags/software-development/">Software Development</a> <a class="post-tag" href="/tags/c-amp/">C++AMP</a> <a class="post-tag" href="/tags/concurrency/">Concurrency</a> <a class="post-tag" href="/tags/gpgpu/">GPGPU</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://faouellet.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
