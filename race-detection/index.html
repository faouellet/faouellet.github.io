<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.7.1"><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="Homemade data race detector" /><meta name="author" content="Félix-Antoine Ouellet" /><meta property="og:locale" content="en_US" /><meta name="description" content="Because why not?" /><meta property="og:description" content="Because why not?" /><link rel="canonical" href="https://faouellet.github.io//race-detection/" /><meta property="og:url" content="https://faouellet.github.io//race-detection/" /><meta property="og:site_name" content="/* Insert Code Here */" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2016-10-10T00:00:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Homemade data race detector" /> <script type="application/ld+json"> {"description":"Because why not?","url":"https://faouellet.github.io//race-detection/","headline":"Homemade data race detector","dateModified":"2016-10-10T00:00:00-04:00","@type":"BlogPosting","datePublished":"2016-10-10T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://faouellet.github.io//race-detection/"},"author":{"@type":"Person","name":"Félix-Antoine Ouellet"},"@context":"https://schema.org"}</script><title>Homemade data race detector | /* Insert Code Here */</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" href="/assets/css/post.css" as="style"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-71911238-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-71911238-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">/* Insert Code Here */</a></div><div class="site-subtitle font-italic"></div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/faouellet" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/felixantoineouellet/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['faouellet','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Homemade data race detector</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Homemade data race detector</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Oct 10, 2016, 12:00 AM -0400" > Oct 10, 2016 <i class="unloaded">2016-10-10T00:00:00-04:00</i> </span> by <span class="author"> Félix-Antoine Ouellet </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2450 words">13 min</span></div></div><div class="post-content"><p><strong>Note 1:</strong> What I’m presenting here is evidently not a production grade tool. In fact, I’d say it barely even qualify as a proof of concept. If you really want to debug multithreaded programs, please use a tool like <a href="https://software.intel.com/en-us/intel-inspector-xe">Intel Inspector</a>, <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual">ThreadSanitizer</a> or <a href="http://valgrind.org/docs/manual/hg-manual.html#hg-manual.data-races">Helgrind</a>.</p><p><strong>Note 2:</strong> While everything here is presented in C++, the algorithm that I’m describing could be implemented and used to detect data races in any other programming language.</p><h2 id="story-time">Story time</h2><p>At my job, I sometimes have to rely upon a race detection tool to figure out why the hell threads aren’t behaving I as expect them to. While it is nice to have something readily available to help you in such cases and not having to think about how you could debug a multithreaded program, I couldn’t help but wonder, how do these kind of tools actually works? And as you know, curiosity is always a good reason to start a programming project.</p><h2 id="whats-a-data-race">What’s a data race?</h2><p>By definition a data race occurs when two or more threads access the same memory location without any locking mechanism and at least one of them is a write access. As an example, take a look at this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">size_t</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threadVec</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">threadVec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="o">&amp;</span><span class="n">data</span><span class="p">]()</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="o">++</span><span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Pop quiz: what’s the value of <code class="language-plaintext highlighter-rouge">data</code> when all threads are finished?</p><p>Answer: Something between 0 and 1000000. We can’t say which value precisely because there are way too many unsynchronized accesses to <code class="language-plaintext highlighter-rouge">data</code>.</p><p>This goes to show that, as in real life, if you don’t use protection you’re bound to catch some bugs.</p><p>(However, compilers can exploit the fact that a data race induces undefined behavior in the program and remove the threads altogether leaving only the incrementation of the variable in the outputted binary.)</p><h2 id="keeping-track-of-memory-accesses">Keeping track of memory accesses</h2><p>One of our first job will then be to create a structure to help us keep track of memory accesses. Here’s what I propose:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="n">TID</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">ShadowState</span>
<span class="p">{</span>
  <span class="n">TID</span> <span class="n">AccessorID</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">AccessorClock</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">IsWrite</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="n">ShadowState</span><span class="o">&gt;</span> <span class="n">MemoryState</span><span class="p">;</span>
</pre></table></code></div></div><p>Going in reverse order, we first have the <code class="language-plaintext highlighter-rouge">MemoryState</code> structure that will associate a memory location with a <code class="language-plaintext highlighter-rouge">ShadowState</code>. It goes without saying that this structure will be at the heart of our race detection algorithm.</p><p>Next, we have the <code class="language-plaintext highlighter-rouge">ShadowState</code> structure which will keep some interesting informations about a memory access. It will tell us if the access was a write access through the <code class="language-plaintext highlighter-rouge">IsWrite</code> data member (needed because reads alone can’t cause a data race). It will also indicate which thread is doing the access by keeping its ID (<code class="language-plaintext highlighter-rouge">AccessorID</code>). Finally, it will tell us at which point in the accessor’s thread’s clock the access happened. This will be crucial to establish (or not if there’s a race) a happens-before relation between two memory access.</p><h2 id="a-clock-for-multithreaded-program">A clock for multithreaded program</h2><p>When diving into the world of parallel programming, one thing you have to realize is that you can’t cling to your old notions about time. Things won’t happen at a precise moment in time like they used to in sequential programs. There’s now a non-determinism in our programs that makes ordering events a much more complicated matter.</p><p>So how do we make sense of the events? How do we establish a relation between two events in a multithread context?</p><p>One way to do so is by using vector clocks. The basic principle behind these clocks is that each thread will possess a series of clock that will keep track of the time of every thread in the system in terms of memory access and synchronization events. Also, and probably more importantly, all the clocks in a given vector clock will only have the values that the owner thread can perceive at a given moment.</p><p>Sounds too complicated? Let’s try again with an example. For this, we’ll be using a simplified version of the data race example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">size_t</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threadVec</span><span class="p">;</span>

<span class="c1">// Starting T1</span>
<span class="n">threadVec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="o">&amp;</span><span class="n">data</span><span class="p">]()</span> <span class="p">{</span> <span class="o">++</span><span class="n">data</span><span class="p">;</span> <span class="p">});</span>

<span class="c1">// Starting T2</span>
<span class="n">threadVec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="o">&amp;</span><span class="n">data</span><span class="p">]()</span> <span class="p">{</span> <span class="o">++</span><span class="n">data</span><span class="p">;</span> <span class="p">});</span>
</pre></table></code></div></div><p>Now let’s draw a picture of what’s happening in this program with regards to accesses to the <code class="language-plaintext highlighter-rouge">data</code> variable:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/program.png" alt="Desktop View" /></p><p>Next, let’s introduce vector clocks in the picture:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/vector.png" alt="Desktop View" /></p><p>As you can see, each thread has in its possession a series of clock that are incremented with each memory access. Since there is no synchronization between threads, they do not communicate their clock’s states with each other.</p><h2 id="the-happens-before-relation">The happens-before relation</h2><p>A happens-before relation is an ordering relation between two memory accesses. Having such a relation means that whatever the order in which the other memory accesses in a given program will be executed (remember multithreading introduces non-determinism in a program), the two accesses that shares this relation will always happen in the order prescribed by the relation. To determine that such a relation is present between two memory access, you only have to look at their vector clocks. If one of the access’ clocks’ values are all inferior to the other’s clocks’ values, then we have a happens-before relation.</p><p>With the happens-before relation defined, we can now produce an algorithm to detect data races in a program. Basically, we’ll say that there’s is a data race if these 3 criteria are met:</p><ul><li>They must happen on different threads (Obviously, you can’t race with yourself!)<li>One of the accesses must be a write (We can’t have races with just read)<li>We can’t define a happens-before relation between the events (No ordering means a lack of synchronized accesses)</ul><p>If we look at our previous example through this algorithm, we can clearly see that it doesn’t respect the third criteria. This should serve as proof that the proposed criteria are enough to prove that a program contains data race.</p><h2 id="implementing-happens-before">Implementing happens-before</h2><p>Obviously, for implementing happens-before, we’ll need an abstraction descibing a vector clock.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="n">ThreadClock</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">TID</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">TID</span><span class="p">,</span> <span class="n">ThreadClock</span><span class="o">&gt;</span> <span class="n">ThreadStates</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ConcurrentAccessCount</span><span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
</pre></table></code></div></div><p>With <code class="language-plaintext highlighter-rouge">ThreadClock</code> I can then define <code class="language-plaintext highlighter-rouge">ThreadStates</code> which will help keep track of the each thread vector clock. Of course, this isn’t really a good practice to have such a global variable, but for rapid prototyping, I’d say that we can make an exception. Another thing I’ve added is a counter that will keep track of how many concurrent accesses have been performed during the program’s execution.</p><p>With this, we have all we need to implement our race detection algorithm.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">CheckForConcurrentAccess</span><span class="p">(</span><span class="k">const</span> <span class="n">ShadowState</span><span class="o">&amp;</span> <span class="n">oldState</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">ShadowState</span><span class="o">&amp;</span> <span class="n">newState</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Condition 1:</span>
  <span class="c1">// You can't race with yourself</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">oldState</span><span class="p">.</span><span class="n">AccessorID</span> <span class="o">==</span> <span class="n">newState</span><span class="p">.</span><span class="n">AccessorID</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Condition 2:</span>
  <span class="c1">// For a data race to occurs we need at least one write access</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oldState</span><span class="p">.</span><span class="n">IsWrite</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">newState</span><span class="p">.</span><span class="n">IsWrite</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Condition 3:</span>
  <span class="c1">// A data race happens when not every element of the current</span>
  <span class="c1">// accessor's vector clock is less than the corresponding element</span>
  <span class="c1">// in the previous accessor's vector clock.</span>
  <span class="k">auto</span> <span class="n">happensBefore</span> <span class="o">=</span> <span class="p">[](</span><span class="n">ThreadClock</span><span class="o">&amp;</span> <span class="n">eventClock1</span><span class="p">,</span>
                          <span class="n">ThreadClock</span><span class="o">&amp;</span> <span class="n">eventClock2</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">all_of</span><span class="p">(</span>
        <span class="n">eventClock1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">eventClock1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="n">eventClock2</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TID</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">&gt;&amp;</span> <span class="n">thread1Time</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="k">return</span> <span class="n">thread1Time</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;=</span> <span class="n">eventClock2</span><span class="p">[</span><span class="n">thread1Time</span><span class="p">.</span><span class="n">first</span><span class="p">];</span>
        <span class="p">});</span>
  <span class="p">};</span>

  <span class="n">ThreadClock</span><span class="o">&amp;</span> <span class="n">currAccessorClock</span> <span class="o">=</span> <span class="n">ThreadStates</span><span class="p">[</span><span class="n">newState</span><span class="p">.</span><span class="n">AccessorID</span><span class="p">];</span>
  <span class="n">ThreadClock</span><span class="o">&amp;</span> <span class="n">prevAccessorClock</span> <span class="o">=</span> <span class="n">ThreadStates</span><span class="p">[</span><span class="n">oldState</span><span class="p">.</span><span class="n">AccessorID</span><span class="p">];</span>

  <span class="c1">// Can we order the two accesses with a happens-before relation?</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">happensBefore</span><span class="p">(</span><span class="n">currAccessorClock</span><span class="p">,</span> <span class="n">prevAccessorClock</span><span class="p">)</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">happensBefore</span><span class="p">(</span><span class="n">prevAccessorClock</span><span class="p">,</span> <span class="n">currAccessorClock</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">ConcurrentAccessCount</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="funneling-reads-and-writes">Funneling reads and writes</h2><p>Since this is a prototype that we’re writing, instead of instrumenting the program’s binary, we will propose an interface to keep track of the read and write event of the program.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">Read</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Incrementing the current thread clock</span>
  <span class="k">const</span> <span class="n">TID</span> <span class="n">currentTID</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">();</span>
  <span class="o">++</span><span class="n">ThreadStates</span><span class="p">[</span><span class="n">currentTID</span><span class="p">].</span><span class="n">Clock</span><span class="p">[</span><span class="n">currentTID</span><span class="p">];</span>

  <span class="c1">// Checking for potential race condition</span>
  <span class="n">ShadowState</span> <span class="n">newState</span><span class="p">{</span><span class="n">currentTID</span><span class="p">,</span> <span class="n">ThreadStates</span><span class="p">[</span><span class="n">thisTID</span><span class="p">].</span><span class="n">Clock</span><span class="p">[</span><span class="n">thisTID</span><span class="p">],</span><span class="cm">/*IsWrite=*/</span><span class="nb">false</span><span class="p">};</span>
  <span class="n">CheckForConcurrentAccess</span><span class="p">(</span><span class="n">MemoryState</span><span class="p">[</span><span class="o">&amp;</span><span class="n">val</span><span class="p">],</span> <span class="n">newState</span><span class="p">);</span>

  <span class="n">MemoryState</span><span class="p">[</span><span class="o">&amp;</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">newState</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">Write</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">oldVal</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">newVal</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Incrementing the current thread clock</span>
  <span class="k">const</span> <span class="n">TID</span> <span class="n">currentTID</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">();</span>
  <span class="o">++</span><span class="n">ThreadStates</span><span class="p">[</span><span class="n">currentTID</span><span class="p">][</span><span class="n">currentTID</span><span class="p">];</span>

  <span class="c1">// Checking for potential race condition</span>
  <span class="n">ShadowState</span> <span class="n">newState</span><span class="p">{</span><span class="n">currentTID</span><span class="p">,</span>
                       <span class="n">ThreadStates</span><span class="p">[</span><span class="n">currentTID</span><span class="p">][</span><span class="n">currentTID</span><span class="p">],</span>
                       <span class="cm">/*IsWrite=*/</span><span class="nb">true</span><span class="p">};</span>
  <span class="n">CheckForConcurrentAccess</span><span class="p">(</span><span class="n">MemoryState</span><span class="p">[</span><span class="o">&amp;</span><span class="n">oldVal</span><span class="p">],</span> <span class="n">newState</span><span class="p">);</span>

  <span class="c1">// Writing new values</span>
  <span class="n">MemoryState</span><span class="p">[</span><span class="o">&amp;</span><span class="n">oldVal</span><span class="p">]</span> <span class="o">=</span> <span class="n">newState</span><span class="p">;</span>
  <span class="n">oldVal</span> <span class="o">=</span> <span class="n">newVal</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h2 id="lets-put-it-to-the-test">Let’s put it to the test</h2><p>Let’s write a racy program that makes use of the race detector interface:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threadVec</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">threadVec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="o">&amp;</span><span class="n">data</span><span class="p">]()</span>
                           <span class="p">{</span>
                              <span class="n">Write</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                           <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">th</span> <span class="o">:</span> <span class="n">threadVec</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">th</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Concurrent accesses found: "</span>
            <span class="o">&lt;&lt;</span> <span class="n">ConcurrentAccessCount</span><span class="p">.</span><span class="n">load</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This should do it. Let’s see what we got after some test runs using a Python test script.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/racefound1.png" alt="Desktop View" /></p><p>It works!</p><h2 id="what-about-locks">What about locks?</h2><p>Memory accesses aren’t the only things that we can track using vector clocks. Synchronization events like locking or unlocking a mutex are also an important part of the happens-before framework that we’re building. In fact, they are the means by which threads will communicate their vector clocks information between each other.</p><p>Let’s illustrate what I mean by an example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">size_t</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threadVec</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mut</span><span class="p">;</span>

<span class="c1">// Starting T1</span>
<span class="n">threadVec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="o">&amp;</span><span class="n">data</span><span class="p">](){</span> <span class="n">mut</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="o">++</span><span class="n">data</span><span class="p">;</span> <span class="n">mut</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="p">});</span>

<span class="c1">// Starting T2</span>
<span class="n">threadVec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="o">&amp;</span><span class="n">data</span><span class="p">](){</span> <span class="n">mut</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="o">++</span><span class="n">data</span><span class="p">;</span> <span class="n">mut</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="p">});</span>
</pre></table></code></div></div><p>This program can be represented as follows (vector clocks and all):</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/synch.png" alt="Desktop View" /></p><p>Note that this is only one of the two possible orderings of this program. But regardless of the ordering chosen for this example, the fact remains that we can now establish a happens-before relation between the accesses to <code class="language-plaintext highlighter-rouge">data</code>. As you know, only one thread can acquire a mutex at a time. This means that the other thread that wants the mutex will come to a halt while waiting for it. What’s probably new is that when a thread acquires the mutex, it will also acquire the most up to date clocks’ states that the mutex has seen so far.</p><h2 id="a-mutex-for-our-race-detector">A mutex for our race detector</h2><p>Our mutex implementation will be quite minimal. It will wrap a <code class="language-plaintext highlighter-rouge">std::mutex</code> and will keep a <code class="language-plaintext highlighter-rouge">ThreadClock</code> to help transmit clocks’ states between threads.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Mutex</span>
<span class="p">{</span>
<span class="nl">private:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mMutex</span><span class="p">;</span>
  <span class="n">ThreadClock</span> <span class="n">mClock</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Unlocking our mutex will update both the mutex’ and the current thread’s clock.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Unlock</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="n">TID</span> <span class="n">thisTID</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">();</span>
  <span class="n">ThreadClock</span><span class="o">&amp;</span> <span class="n">accessorClock</span> <span class="o">=</span> <span class="n">ThreadStates</span><span class="p">[</span><span class="n">thisTID</span><span class="p">];</span>

  <span class="c1">// Update the accessor clock and mutex clock</span>
  <span class="o">++</span><span class="n">accessorClock</span><span class="p">[</span><span class="n">thisTID</span><span class="p">];</span>
  <span class="n">mClock</span><span class="p">[</span><span class="n">thisTID</span><span class="p">]</span> <span class="o">=</span> <span class="n">accessorClock</span><span class="p">[</span><span class="n">thisTID</span><span class="p">];</span>

  <span class="n">mMutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>While locking the mutex, we will proceed to update the mutex’ and current thread’s clocks. This will be done by assigning the maximum value of a clock to both the mutex’ and the current thread’s vector clock.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Lock</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">mMutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">TID</span> <span class="n">thisTID</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">();</span>
  <span class="n">ThreadClock</span><span class="o">&amp;</span> <span class="n">accessorClock</span> <span class="o">=</span> <span class="n">ThreadStates</span><span class="p">[</span><span class="n">thisTID</span><span class="p">];</span>

  <span class="o">++</span><span class="n">accessorClock</span><span class="p">[</span><span class="n">thisTID</span><span class="p">];</span>

  <span class="c1">// During a receive event, we synchronize the accessor clock with</span>
  <span class="c1">// the mutex clock. Afterwards, both will have the most up to date</span>
  <span class="c1">// vector clock possible.</span>
  <span class="n">mClock</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">accessorClock</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">accessorClock</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">thTime</span> <span class="o">:</span> <span class="n">mClock</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">maxClockTime</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">accessorClock</span><span class="p">[</span><span class="n">thTime</span><span class="p">.</span><span class="n">first</span><span class="p">],</span> <span class="n">thTime</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
    <span class="n">thTime</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">maxClockTime</span><span class="p">;</span>
    <span class="n">accessorClock</span><span class="p">[</span><span class="n">thTime</span><span class="p">.</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxClockTime</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="does-this-still-work">Does this still work?</h2><p>Taking our previous test and inserting proper synchronization in it will result in this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threadVec</span><span class="p">;</span>

  <span class="n">Mutex</span> <span class="n">mut</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">threadVec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mut</span><span class="p">]()</span>
                           <span class="p">{</span>
                              <span class="n">mut</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
                              <span class="n">Write</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
                              <span class="n">mut</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
                           <span class="p">});</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">th</span> <span class="o">:</span> <span class="n">threadVec</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">th</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Concurrent accesses found: "</span>
            <span class="o">&lt;&lt;</span> <span class="n">ConcurrentAccessCount</span><span class="p">.</span><span class="n">load</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Taking it for run with the same Python test script as before yields:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/racefound2.png" alt="Desktop View" /></p><p>It stil works!</p><h2 id="what-do-real-race-detectors-do">What do “real” race detectors do?</h2><p>What I’ve just shown you is a basic framework for something that is called pure happens-before race detection. While it is a good start for a race detector, it is by no means a perfect solution. For one, it is way too much intrusive. Also, since it’s a dynamic race detector, its results will greatly vary depending on the given execution order of a program. This could go as far as declaring a program race-free when it isn’t.</p><p>In real life, the race detectors that I know of often work by instrumenting the binary produced from a program. This means that all those loops our test programs had to jump through by using a cumbersome interface aren’t required. Instead, the compiler will put them in place for directly in the program’s binary.</p><p>It also goes without saying that they use much more powerful algorithms than what I’ve shown here. From what I can gather, their algorithms often are a mix combining more advanced happens-before-based race detection algorithms and other algorithms based on correct mutex use. Some even throw sampling into the mix. This goes to show that rabbit hole of race detectors still goes deeper than what I’ve presented in this post.</p><h2 id="the-more-you-know">The more you know</h2><ul><li>All the code for this article can be found <a href="https://github.com/faouellet/Sandbox/blob/master/Parallelism/racedetection.cpp">here</a>.<li>This post draws most of its inspiration of from Kavya Joshi’s <a href="https://www.youtube.com/watch?v=5erqWdlhQLA">“go test -race” Under the Hood</a>. Basically, I just wanted to have a concrete implementation of the content of that presentation.<li>If you want to know more about vector clocks, you have to read Leslie Lamport’s seminal papers: <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf">Time, Clocks, and the Ordering of Events in a Distributed System</a><li>When defining the <code class="language-plaintext highlighter-rouge">ShadowState</code> structure, what I’m really doing is implementing probably the most rudimentary form of what is called shadow memory. A good article to wrap your head around this concept is <a href="http://www-leland.stanford.edu/class/cs343/resources/shadow-memory2007.pdf">How to Shadow Every Byte of Memory Used by a Program</a><li>For those that want to explore other approaches to race detection, I suggest reading <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/pldi09.pdf">LiteRace: Effective Sampling for Lightweight Data-Race Detection</a> which attacks the problem from a more statistical angle.</ul></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/parallelism/" class="post-tag no-text-decoration" >Parallelism</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Homemade data race detector - /* Insert Code Here */&url=https://faouellet.github.io//race-detection/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Homemade data race detector - /* Insert Code Here */&u=https://faouellet.github.io//race-detection/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Homemade data race detector - /* Insert Code Here */&url=https://faouellet.github.io//race-detection/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/database/">Database</a> <a class="post-tag" href="/tags/source-control/">Source Control</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/build-system/">Build System</a> <a class="post-tag" href="/tags/parallelism/">Parallelism</a> <a class="post-tag" href="/tags/compiler-development/">Compiler Development</a> <a class="post-tag" href="/tags/software-development/">Software Development</a> <a class="post-tag" href="/tags/c-amp/">C++AMP</a> <a class="post-tag" href="/tags/concurrency/">Concurrency</a> <a class="post-tag" href="/tags/gpgpu/">GPGPU</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/ampr/"><div class="card-body"> <span class="timeago small" > Nov 19, 2016 <i class="unloaded">2016-11-19T00:00:00-05:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>AMPR</h3><div class="text-muted small"><p> All the code for this article can be found here. Have you ever asked yourself: how do regexes works? Or, even better, have you ever thought that you could totally implement a regex engine that...</p></div></div></a></div><div class="card"> <a href="/csgames-simple/"><div class="card-body"> <span class="timeago small" > Feb 5, 2016 <i class="unloaded">2016-02-05T00:00:00-05:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>CS Games 2015 Parallelism Challenge - A Simple Solution</h3><div class="text-muted small"><p> What’s up people! Now that a month has passed, surely you have found a, at least simple, solution to the challenge? Now, as I promised last month, let’s go over a simple solution for this challe...</p></div></div></a></div><div class="card"> <a href="/csgames-efficient/"><div class="card-body"> <span class="timeago small" > Mar 3, 2016 <i class="unloaded">2016-03-03T00:00:00-05:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>CS Games 2015 Parallelism Challenge - A More Efficient Solution</h3><div class="text-muted small"><p> What’s up people! Last time, we went over some potential solutions for a problem given during the parallelism challenge. As you may remember (if you don’t, go here), I put a special emphasis on ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/enumerate/" class="btn btn-outline-primary"><p>Python-like enumeration in C++</p></a> <a href="/ampr/" class="btn btn-outline-primary"><p>AMPR</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="font-italic text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> var options = { scriptUrl: '//insertcodehere.disqus.com/embed.js', disqusConfig: function() { this.page.url = 'https://faouellet.github.io//race-detection/'; this.page.identifier = '/race-detection/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/faouellet">Félix-Antoine Ouellet</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/database/">Database</a> <a class="post-tag" href="/tags/source-control/">Source Control</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/build-system/">Build System</a> <a class="post-tag" href="/tags/parallelism/">Parallelism</a> <a class="post-tag" href="/tags/compiler-development/">Compiler Development</a> <a class="post-tag" href="/tags/software-development/">Software Development</a> <a class="post-tag" href="/tags/c-amp/">C++AMP</a> <a class="post-tag" href="/tags/concurrency/">Concurrency</a> <a class="post-tag" href="/tags/gpgpu/">GPGPU</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://faouellet.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
